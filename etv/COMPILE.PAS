USES STR_FUNC,CRT,dos;

CONST
	MASK:ARRAY[1..17] OF STRING=(
 {1}	'@$-[    ]',
 {2}	'@{"',
 {3}	'@/START',
 {4}	'@/END',
 {5}	'@SS[   :   ]',
 {6}	'@CS[   :   ]',
 {7}	'@HS[   :   ]',
 {8}	'@PR[   :   ]->[    ]',
 {9}	'@RR[   :   ]->[    :   ]',
{10} 	'@FP[   :   ]->[    ]:[        .   ]',
{11}	'@FR[   :   ]->[    :   ]:[        .   ]',
{12}	'@LC',
{13}	'@CC',
{14}	'@RC',
{15}	'@REM',
{16}	'@DM',
{17}	'@SP[  ]');

TYPE
	COMMAND=RECORD
	CT:BYTE;
	START,LEN,PAR,PROW:WORD;
	FNAME:STRING[8];
	FEXT:STRING[3];
	END;

	PWordArr=^TWordArr;
	TWordArr=ARRAY[0..9999] OF WORD;

	PMEM=^TMEM;
	TMEM=ARRAY[0..63999] OF BYTE;

	PROW=^TROW;
	TROW=RECORD
	NCOM:BYTE;
	COMMANDS:ARRAY[1..40] OF COMMAND;
	TSIZE:WORD;
	PTEXT:PMEM;
	END;

	PARAGRAPH=RECORD
	PARNUM:WORD;
	NROWS:BYTE;
	TSIZE1:WORD;
	PTEXT1:PMEM;
	PDATA:ARRAY[1..255] OF PROW;
	END;

	FNT=STRING[12];

	OFNUM=RECORD
	NUM:WORD;
	OFST:LONGINT;
	END;

	PHEADER=^THEADER;
	THEADER=RECORD
	NPAR:WORD;
	OFN:ARRAY[0..9999] OF OFNUM;
	END;

VAR CMD:COMMAND;
	CP:WORD;
	PR:PARAGRAPH;
	F:TEXT;
	FT:FILE OF FNT;
	SF:FNT;
	S:STRING;
	N:LONGINT;
	INPAR:BOOLEAN;
	ISDM:BOOLEAN;
	SPNUM:BYTE;
	GETHEADER:BOOLEAN;
	target,dest:string;

FUNCTION ISINFT(SA:FNT):BOOLEAN;
VAR I:WORD;
	SS:FNT;
	AA:BOOLEAN;
BEGIN
CLOSE(FT);
RESET(FT);
AA:=FALSE;
WHILE NOT EOF(FT) DO
BEGIN
READ(FT,SS);
IF SA=SS THEN AA:=TRUE;
END;
ISINFT:=AA;
END;

PROCEDURE ROWINIT(VAR P:PARAGRAPH;N:BYTE);
BEGIN
{IF P.PDATA[N]<>NIL THEN EXIT;}
IF MAXAVAIL<SIZEOF(TROW) THEN BEGIN
TEXTATTR:=15;
WRITELN(#13#10#7'ERROR: NOT ENOUGH MEMORY ...');
READKEY;
HALT;
END;
NEW(P.PDATA[N]);
WITH P.PDATA[N]^ DO BEGIN
NCOM:=0;
TSIZE:=0;
END;
END;

PROCEDURE ROWKILL(VAR P:PARAGRAPH;N:BYTE);
BEGIN
{IF P.PDATA[N]=NIL THEN EXIT;}
WITH P.PDATA[N]^ DO BEGIN
NCOM:=0;
IF TSIZE>0 THEN FREEMEM(PTEXT,TSIZE);
TSIZE:=0;
END;
DISPOSE(P.PDATA[N]);
END;

PROCEDURE PARINIT(VAR P:PARAGRAPH; NUM:WORD);
BEGIN
WITH P DO BEGIN
PARNUM:=NUM;
NROWS:=0;
TSIZE1:=0;
END;
END;

PROCEDURE PARKILL(VAR P:PARAGRAPH);
VAR I:BYTE;
BEGIN
WITH P DO BEGIN
IF TSIZE1>0 THEN FREEMEM(PTEXT1,TSIZE1);
TSIZE1:=0;
FOR I:=1 TO NROWS DO ROWKILL(P,I);
NROWS:=0;
END;
END;

PROCEDURE ADDROW(VAR P:PARAGRAPH);
BEGIN
WITH P DO BEGIN
IF NROWS=255 THEN EXIT;
INC(NROWS);ROWINIT(P,NROWS);
END;
END;

PROCEDURE STRADD(VAR PTEXT:PMEM; VAR TSIZE:WORD; S:STRING);
VAR PS:PMEM;
	OS:WORD;
	L:BYTE;
BEGIN
L:=LENGTH(S);
OS:=TSIZE;
IF OS>=65520 THEN EXIT;
IF OS+L>65520 THEN L:=65520-OS;
IF OS>0 THEN
BEGIN
{	WRITELN(N,' ',OS,' ',TSIZE);}
	GETMEM(PS,OS);
	MOVE(PTEXT^[0],PS^[0],OS);
	FREEMEM(PTEXT,OS);
END;
GETMEM(PTEXT,OS+L);
IF OS>0 THEN
BEGIN
	MOVE(PS^[0],PTEXT^[0],OS);
	FREEMEM(PS,OS);
END;
MOVE(S[1],PTEXT^[OS],L);
TSIZE:=OS+L;
END;

PROCEDURE ADDCOMMAND(R:PROW; C:COMMAND);
BEGIN
{IF R=NIL THEN EXIT;}
WITH R^ DO BEGIN
IF NCOM+1>40 THEN EXIT;
INC(NCOM);COMMANDS[NCOM]:=C;
END;
END;

FUNCTION ISEQ(S:STRING;N:BYTE):BOOLEAN;
VAR I:BYTE;
	SS:STRING;
BEGIN
ISEQ:=FALSE;
IF NOT N IN [1..17] THEN EXIT;
SS:=ALLTRIM(UPPER(MASK[N]));
S:=ALLTRIM(S);
IF LENGTH(SS)>LENGTH(S) THEN EXIT;
FOR I:=1 TO LENGTH(SS) DO IF (SS[I]<>#32) AND (S[I]<>SS[I]) THEN EXIT;
ISEQ:=TRUE;
END;

PROCEDURE FILLCOMMAND(S:STRING; N:BYTE);
BEGIN
WITH CMD DO
BEGIN
START:=0;LEN:=0;PAR:=0;PROW:=0;FNAME:='';FEXT:='';
CT:=N;
CASE N OF
1:BEGIN CP:=VAL_(COPY(S,5,4));START:=VAL_(COPY(S,5,4));END;
5..7:BEGIN START:=VAL_(COPY(S,5,3));LEN:=VAL_(COPY(S,9,3));END;
8:BEGIN START:=VAL_(COPY(S,5,3));LEN:=VAL_(COPY(S,9,3));
		PAR:=VAL_(COPY(S,16,4));END;
9:BEGIN START:=VAL_(COPY(S,5,3));LEN:=VAL_(COPY(S,9,3));
		PAR:=VAL_(COPY(S,16,4));PROW:=VAL_(COPY(S,21,3));END;
10:BEGIN START:=VAL_(COPY(S,5,3));LEN:=VAL_(COPY(S,9,3));
		PAR:=VAL_(COPY(S,16,4));FNAME:=COPY(S,23,8);
		FEXT:=COPY(S,32,3);END;
11:BEGIN START:=VAL_(COPY(S,5,3));LEN:=VAL_(COPY(S,9,3));
		PAR:=VAL_(COPY(S,16,4));PROW:=VAL_(COPY(S,21,3));
		FNAME:=COPY(S,27,8);FEXT:=COPY(S,36,3);END;
17:LEN:=VAL_(COPY(S,5,2));
END;
END;
END;

FUNCTION WHICH(S:STRING):BYTE;
VAR I:BYTE;
BEGIN
S:=UPPER(S);
FOR I:=1 TO 17 DO IF ISEQ(S,I) THEN BEGIN WHICH:=I;IF I<>15 THEN
BEGIN
FILLCOMMAND(S,I);
EXIT;
END;
END;
WHICH:=0;
END;

PROCEDURE GETROWFROMF(VAR F:TEXT;VAR PTEXT:PMEM; VAR TSIZE:WORD; SS:STRING);
VAR LAST:BOOLEAN;
	S:STRING;
BEGIN
S:=SS;
IF RIGHT_(ALLTRIM(S),1)='"' THEN LAST:=TRUE ELSE LAST:=FALSE;
IF LAST THEN S:=LEFT_(S,LENGTH(S)-1);
IF NOT ISDM THEN BEGIN
S:=DELEXTRASP(PUTSPACES(S));
IF SPNUM>0 THEN S:=CHAR_REPL(SPNUM,' ')+S ELSE S:='    '+S;
END ELSE LAST:=TRUE;
STRADD(PTEXT,TSIZE,S);
IF LAST THEN EXIT;
REPEAT
IF EOF(F) THEN BEGIN
WRITELN(#13#10#7#7#7'ERROR: END OF FILE ...');
READKEY;
HALT;
END;
READLN(F,S);
IF RIGHT_(ALLTRIM(S),1)='"' THEN LAST:=TRUE;
IF LAST THEN S:=LEFT_(S,LENGTH(S)-1);
S:=' '+DELEXTRASP(PUTSPACES(S));
STRADD(PTEXT,TSIZE,S);
UNTIL LAST;
END;

PROCEDURE FIX(P:PARAGRAPH);
VAR F:FILE;
	FN:STRING;
	I,J:BYTE;
BEGIN
WITH P DO BEGIN
FN:='TMP\'+LEFT_(STR_(PARNUM)+CHAR_REPL(8,'_'),8)+'.SRC';
ASSIGN(F,FN);
REWRITE(F,1);
BLOCKWRITE(F,PARNUM,5);
BLOCKWRITE(F,PTEXT1^,TSIZE1);
FOR I:=1 TO NROWS DO WITH PDATA[I]^ DO
BEGIN
BLOCKWRITE(F,NCOM,1);
FOR J:=1 TO NCOM DO BLOCKWRITE(F,COMMANDS[J],9);
BLOCKWRITE(F,TSIZE,2);
BLOCKWRITE(F,PTEXT^,TSIZE);
END;
END;
CLOSE(F);
END;

FUNCTION CLEANIT(SS:STRING):STRING;
VAR S:STRING;
BEGIN
S:=SS;
WHILE S[LENGTH(S)]='_' DO S:=LEFT_(S,LENGTH(S)-1);
CLEANIT:=S;
END;

VAR SSF:BOOLEAN;

PROCEDURE DOMAIN(FILENAME:STRING);
LABEL FINISH;
BEGIN
SSF:=FALSE;
WRITELN('FILE : ',FILENAME);
ASSIGN(F,FILENAME);
RESET(F);
INPAR:=FALSE;
SPNUM:=0;
GETHEADER:=FALSE;
WHILE NOT EOF(F) DO
BEGIN
REPEAT
READLN(F,S); INC(N);
cleantab(s);
UNTIL (LENGTH(ALLTRIM(S))>0) or (eof(f));
IF ALLTRIM(S)='---@---' THEN BEGIN SSF:=TRUE;GOTO FINISH;END;
FILLCOMMAND(S,WHICH(alltrim(S)));
IF GETHEADER THEN
BEGIN
		GETROWFROMF(F,PR.PTEXT1,PR.TSIZE1,RIGHT_(S,LENGTH(S)-1));
		GETHEADER:=FALSE;
END ELSE
WITH CMD DO
CASE CT OF
 0: IF LEFT_(ALLTRIM(S),1)='"' THEN BEGIN
		GETROWFROMF(F,PR.PDATA[PR.NROWS]^.PTEXT,PR.PDATA[PR.NROWS]^.TSIZE,RIGHT_(S,LENGTH(S)-1));
		ADDROW(PR);
		ISDM:=FALSE;
		SPNUM:=0;
	END;
 1:	BEGIN
		WRITELN('# ',START);
		SPNUM:=0;
		PARINIT(PR,START);
	END;
 2: BEGIN
		GETHEADER:=TRUE;
	END;
 3: BEGIN
		IF INPAR THEN
		BEGIN
			TEXTATTR:=12;
			WRITELN(#13#10#7#7#7'ERROR: LINE # ',N:10);
			WRITELN('NEXT PARAGRAPH STARTED WITHOUT ENDING PREVIOUS ...');
			READKEY;
			HALT;
		END;
		ADDROW(PR);
	END;
 4: BEGIN
		FIX(PR);
		PARKILL(PR);
	END;
 5..9,12..14: ADDCOMMAND(PR.PDATA[PR.NROWS],CMD);
 10..11:
	BEGIN
	SF:=CLEANIT(CMD.FNAME)+'.'+CLEANIT(CMD.FEXT);
	IF NOT ISINFT(SF) THEN BEGIN WRITE(FT,SF);END;
	ADDCOMMAND(PR.PDATA[PR.NROWS],CMD);
	END;
16: BEGIN
		ISDM:=TRUE;
                ADDCOMMAND(PR.PDATA[PR.NROWS],CMD);
	END;
17: BEGIN
		SPNUM:=LEN;
	END;
END;
END;
FINISH:
CLOSE(F);
END;

FUNCTION JUSTNAME(S:STRING):STRING;
var
  P: PathStr;
  D: DirStr;
  N: NameStr;
  E: ExtStr;
begin
  P:=S;
  FSplit(P, D, N, E);
  JUSTNAME:=N;
END;

PROCEDURE LINKALL;
var
  DirInfo: SearchRec;
  f,F1:file;
  HD:PHEADER;
  TT,SZ,SZ1:WORD;
  PP:PMEM;
  TOT:LONGINT;
  spos:word;

FUNCTION COUNT:WORD;
VAR NN:WORD;
BEGIN
  FindFirst('tmp\*.src', anyfile, DirInfo);
	NN:=0;
  while DosError = 0 do WITH HD^ DO
  begin
	INC(NN);
	FindNext(DirInfo);
  end;
  COUNT:=NN;
END;

PROCEDURE CREATEINDEX;
VAR X:TEXT;
    S:STRING;
	p:pwordarr;
BEGIN
new(p);
ASSIGN(X,JUSTNAME(DEST)+'.IND');
p^[0]:=0;
RESET(X);
WHILE NOT EOF(X) DO BEGIN
READLN(X,S);
inc(p^[0]);
P^[P^[0]+1]:=val_(s);
END;
CLOSE(F);
RESET(F,1);
{dec(p^[0]);}
CLOSE(X);
blockwrite(f,p^,(p^[0]+1)*2);
spos:=p^[0]*2+2;
{writeln('        ',p^[0]);
readkey;}
dispose(p);
END;

begin
  SSF:=FALSE;
  TOT:=0;
  NEW(HD);
  NEW(PP);
  HD^.NPAR:=COUNT;
  ASSIGN(F,JUSTNAME(dest)+'.ETF');
  REWRITE(F,1);
  createindex;
  SZ:=2+6*HD^.NPAR;
  BLOCKWRITE(F,HD^,SZ);
  FindFirst('tmp\*.src', anyfile, DirInfo);
  FOR TT:=1 TO HD^.NPAR DO WITH HD^ DO
  begin
	HD^.OFN[TT-1].NUM:=VAL_(CLEANIT(LEFT_(DirInfo.NAME,8)));
	HD^.OFN[TT-1].OFST:=FILEPOS(F);
	ASSIGN(F1,'TMP\'+DirInfo.NAME);
	RESET(F1,1);
	SZ1:=FILESIZE(F1);
	TOT:=TOT+SZ1;
	WRITELN('PLACING ',SZ1,' BYTES FROM ',DIRINFO.NAME);
	BLOCKREAD(F1,PP^,SZ1);
	BLOCKWRITE(F,PP^,SZ1);
	CLOSE(F1);
	FindNext(DirInfo);
  end;
  SEEK(F,spos);
  BLOCKWRITE(F,HD^,SZ);
  CLOSE(F);
  DISPOSE(PP);
  DISPOSE(HD);
  WRITELN('TOTAL SIZE : ',TOT,' BYTES.');
end;

procedure deleall;
var
  DirInfo: SearchRec;
	f:file;
begin
  FindFirst('tmp\*.src', Archive, DirInfo);
  while DosError = 0 do
  begin
	assign(f,'tmp\'+dirinfo.name);
	reset(f,1);
        close(f);
	erase(f);
	writeln(dirinfo.name,' file was just deleted ...');
	FindNext(DirInfo);
  end;
end;

var
  DirInfo: SearchRec;
  np:longint;

BEGIN
  FindFirst('tmp', Directory, DirInfo);
  if doserror<>0 then mkdir('tmp');
ASSIGN(FT,'FILES.LST');
REWRITE(FT);
N:=0;
TEXTATTR:=7;
CLRSCR;
if paramcount=0 then begin
write('Input the name of the target file :');
readln(target);
write('Input the name of the destination file :');
readln(dest);
end else
if paramcount=1 then begin
write('Input the name of the destination file :');
readln(dest);
end else begin target:=paramstr(1);dest:=paramstr(2);end;

{CREATEINDEX(DEST);}

DOMAIN(target);
Close(ft);
IF NOT SSF THEN BEGIN
{ASSIGN(FT,'FILES.LST');}
{$I-}
RESET(FT);
{$I+}
IF IORESULT=0 THEN
WHILE NOT EOF(FT) DO
BEGIN
READ(FT,SF);
DOMAIN(ALLTRIM(SF));
np:=filepos(ft);
close(ft);
reset(ft);
seek(ft,np);
END;
CLOSE(FT);
END;
LINKALL;
deleall;
rmdir('tmp');
END.